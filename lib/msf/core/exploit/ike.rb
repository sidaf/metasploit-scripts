require 'msf/core'

module Msf

###
#
# This module exposes methods for querying a remote IKE service
#
###
  module Exploit::Remote::IKEv1
    module Client

      include Msf::Exploit::Remote::Udp

      MAIN_MODE       = '\x02'
      AGGRESSIVE_MODE = '\x04'

      ENC_DES         = '\x80\x01\x00\x01'
      ENC_IDEA        = '\x80\x01\x00\x02'
      ENC_BLOWFISH    = '\x80\x01\x00\x03'
      ENC_RC5_R16_B64 = '\x80\x01\x00\x04'
      ENC_3DES        = '\x80\x01\x00\x05'
      ENC_CAST        = '\x80\x01\x00\x06'
      ENC_AES_128     = ['\x80\x01\x00\x07', '\x80\x0E\x00\x80']
      ENC_AES_192     = ['\x80\x01\x00\x07', '\x80\x0E\x00\xC0']
      ENC_AES_256     = ['\x80\x01\x00\x07', '\x80\x0E\x01\x00']

      HASH_MD5      = '\x80\x02\x00\x01'
      HASH_SHA1     = '\x80\x02\x00\x02'
      HASH_TIGER    = '\x80\x02\x00\x03'
      HASH_SHA2_256 = '\x80\x02\x00\x04'
      HASH_SHA2_384 = '\x80\x02\x00\x05'
      HASH_SHA2_512 = '\x80\x02\x00\x06'

      AUTH_PSK    = '\x80\x03\x00\x01'
      AUTH_RSA    = '\x80\x03\x00\x03'
      AUTH_ECDSA  = '\x80\x03\x00\x08'
      AUTH_HYBRID = '\x80\x03\xFA\xDD'
      AUTH_XAUTH  = '\x80\x03\xFD\xE9'

      GROUP_MODP768  = '\x80\x04\x00\x01'
      GROUP_MODP1024 = '\x80\x04\x00\x02'
      GROUP_MODP1536 = '\x80\x04\x00\x05'
      GROUP_MODP2048 = '\x80\x04\x00\x0E'

      class Transform
        def initialize(encryption=ENC_3DES, hash=HASH_SHA1, auth=AUTH_PSK, dh_group=GROUP_MODP1024, life_type='\x80\x0b\x00\x01', life_duration='\x00\x0c\x00\x04\x00\x00\x70\x80')
          @encryption = encryption
          @hash = hash
          @auth = auth
          @dh_group = dh_group
          @life_type = life_type
          @life_duration = life_duration
        end
      end

      def initialize(info = {})
        super

        # Register the options that all IKE exploits may make use of.

        register_options(
          [
            Opt::RPORT(500)
          ], Msf::Exploit::Remote::IKEv1
        )

        register_advanced_options(
          [
            Opt::CPORT(500)
          ], Msf::Exploit::Remote::IKEv1
        )

        register_autofilter_ports([500, 4500])
        register_autofilter_services(%W{ ike isakmp })
      end

      # http://www.ciscopress.com/articles/article.asp?p=25474&seqNum=7
      # https://tools.ietf.org/html/rfc2409

      def phase1(mode, transforms, id_type=nil, id='')
        begin
          connect_udp
          isakmp_pkt = generate_packet(rport, transforms, mode, id_type, id)
          udp_socket.write(isakmp_pkt)
          response = udp_socket.get(3)

          return unless response.length > 36 # ISAKMP + 36 -> Notification Data...

          # do stuff with response
          #parse_packet()

        rescue => e
          print_error(e)
        ensure
          disconnect_udp
        end
      end

      def generate_packet(port, transforms, mode, id_type, id)

        # OK, we are going to create this packet backwards so that the lengths can be calculated and inserted

        # Key Exchange, Nonce, and Identification Payloads (Aggressive Mode Only)
        aggressive_payload = ''
        if mode == AGGRESSIVE_MODE
          aggressive_payload = generate_aggressive(port, id, transforms[0].dh_group)
        end

        # Transform Payloads
        transforms_payload = ''
        transforms.each_with_index do |transform, index|
          number = index + 1
          transforms_payload += generate_transform(transform, number, (number == transforms.size))
        end

        # Proposal Payload
        proposal_payload  = ['00'].pack('H*')                               # Proposal
        proposal_payload += ['00'].pack('H*')                               # Critical Bit
        proposal_payload += [sprintf('%04x', 8 + transforms_payload.size)].pack('H*') # Payload Length (152)
        proposal_payload += ['01'].pack('H*')                               # Proposal number
        proposal_payload += ['01'].pack('H*')                               # Protocol ID: ISAKMP (1)
        proposal_payload += ['00'].pack('H*')                               # SPI size: 0
        proposal_payload += [sprintf('%02x', transforms.count)].pack('H*')  # Number of Proposal Transforms

        # Security Association (SA) Payload
        if aggressive
          sa_payload = ['04'].pack('H*')                                    # Next Payload (Key Exchange)
        else
          sa_payload = ['00'].pack('H*')                                    # Next Payload (None)
        end
        sa_payload += ['00'].pack('H*')                                     # Critical Bit: Not Critical
        sa_payload += [sprintf('%04x', 12 + proposal_payload.size + transforms_payload.size)].pack('H*') # Payload Length (164)
        sa_payload += ['00000001'].pack('H*')                               # Domain of Interpretation (DOI): IPSEC (1)
        sa_payload += ['00000001'].pack('H*')                               # Situation: Identity Only (1)

        # Header Payload
        header_payload  = ['0102030405060708'].pack('H*')                   # Initiator SPI
        header_payload += ['0000000000000000'].pack('H*')                   # Responder SPI
        header_payload += ['01'].pack('H*')                                 # Next Payload (Security Association)
        header_payload += ['10'].pack('H*')                                 # Version: 1.0
        if aggressive
          header_payload += ['04'].pack('H*')                               # Exchange type: AGGRESSIVE (04)
        else
          header_payload += ['02'].pack('H*')                               # Exchange type: MAIN (02)
        end
        header_payload += ['00'].pack('H*')                                 # Flags:
        header_payload += ['00000000'].pack('H*')                           # Message ID
        header_payload += [sprintf('%08x', 28 + proposal_payload.size + transforms_payload.size + aggressive_payload.size)].pack('H*') # Payload Length (360)

        # Assemble packet components in correct order and return
        header_payload + sa_payload + proposal_payload + transforms_payload + aggressive_payload
      end

      def generate_transform(transform, number, last)
        if transform.encryption.is_a? Array
          # Handle special case for AES
          enc = transform.encryption[0]
          trans_length = '\x00\x28'
          key_length = transform.encryption[1]
        else
          enc = transform.encryption
          trans_length = '\x00\x24'
          key_length = nil
        end

        if last
          payload  = '\x00'                             # Next Payload (None)
        else
          payload += '\x03'                             # Next Payload (Transform)
        end
        payload += '\x00'                               # Critical Bit
        payload += trans_length                         # Payload Length
        payload += [sprintf('%02x', number)].pack('H*') # Transform number
        payload += '\x01 '                              # Transform ID: KEY_IKE (1)
        payload += '\x00\x00'                           #
        payload += transform.enc                        # Encryption-Algorithm
        payload += transform.hash                       # Hash-Algorithm
        payload += transform.auth                       # Authentication-Method
        payload += transform.group                      # Group-Description
        if key_length
          payload += key_length                         # AES Key Length
        end
        payload += transform.life_type                  # Life-Type
        payload += transform.life_duration              # Life-Duration

        return payload
      end

      def generate_aggressive(port, id_type, id, dh_group)

        # Get length of key data based on diffie
        if dh_group == GROUP_MODP768 then
          key_length = 96
        elsif dh_group == GROUP_MODP1024 then
          key_length = 128
        elsif dh_group == GROUP_MODP1536 then
          key_length = 192
        elsif dh_group == GROUP_MODP2048 then
          raise RuntimeError, 'TODO'
        else
          raise RuntimeError, 'Unknown Diffie Helman Value'
        end

        # Key Exchange Payload
        payload  = ['0a'].pack('H*')                            # Next Payload (Nonce)
        payload += ['00'].pack('H*')                            # Critical Bit
        payload += [sprintf('%04x', key_length + 4)].pack('H*') # Payload Length (132)
        payload += Rex::Text.rand_text_alphanumeric(key_length) # Key Exchange Data
        # Nonce Payload
        payload += ['05'].pack('H*')                            # Next Payload (Identification)
        payload += ['00'].pack('H*')                            # Critical Bit
        payload += ['0018'].pack('H*')                          # Payload Length (24)
        payload += Rex::Text.rand_text_alphanumeric(20)         # Nonce DATA
        # Identification Payload
        payload += ['00'].pack('H*')                            # Next Payload (None)
        payload += ['00'].pack('H*')                            # Critical Bit
        payload += [id.length + 8].pack('n')                    # Payload Length (id + 8)
        payload += ['03'].pack('H*')                            # ID Type (USER_FQDN)
        payload += ['11'].pack('H*')                            # Protocol ID (UDP)
        payload += [port].pack('n')                             # Port (500)
        payload += id if id                                     # Identifier ID

        return payload
      end
    end
  end
end
