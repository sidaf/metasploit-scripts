require 'msf/core'

module Msf

###
#
# This module exposes methods for querying a remote IKE service
#
###
  module Exploit::Remote::IKEv1

    include Msf::Exploit::Remote::Udp

    ENC_METHOD = {
      'DES'         => '80010001',
      'IDEA'        => '80010002',
      'BLOWFISH'    => '80010003',
      'RC5-R16-B64' => '80010004',
      '3DES'        => '80010005',
      'CAST'        => '80010006',
      'AES/128'     => ['80010007', '800E0080' ],
      'AES/192'     => ['80010007', '800E00C0' ],
      'AES/256'     => ['80010007', '800E0100' ]
    }.freeze

    HASH_ALGORITHM = {
      'MD5'      => '80020001',
      'SHA1'     => '80020002',
      'TIGER'    => '80020003',
      'SHA2-256' => '80020004',
      'SHA2-384' => '80020005',
      'SHA2-512' => '80020006'
    }.freeze

    AUTH_TYPE = {
      'PSK'    => '80030001',
      'RSA'    => '80030003',
      'ECDSA'  => '80030008',
      'HYBRID' => '8003FADD',
      'XAUTH'  => '8003FDE9'
    }.freeze

    GROUP_DESCRIPTION = {
      '768'  => '80040001',
      '1024' => '80040002',
      '1536' => '80040005',
      '2048' => '8004000E'
    }.freeze


    def initialize(info = {})
      super

      # Register the options that all IKE exploits may make use of.

      register_options(
        [
          Opt::RPORT(500)
        ], Msf::Exploit::Remote::IKEv1
      )

      register_advanced_options(
        [
          Opt::CPORT(500)
        ], Msf::Exploit::Remote::IKEv1
      )

      register_autofilter_ports([ 500 ])
      register_autofilter_services(%W{ ike isakmp })
    end

    # http://www.ciscopress.com/articles/article.asp?p=25474&seqNum=7
    # https://tools.ietf.org/html/rfc2409

    def send_isakmp_phase1_aggressive_mode_init(transforms, diffie_hellman, identifier)
      # On the first exchange, almost everything is squeezed into the proposed IKE SA values: the Diffie-Hellman public
      # key; a nonce that the other party signs; and an identity packet, which can be used to verify identity via a
      # third party. The receiver sends everything back that is needed to complete the exchange. The only thing left is
      # for the initiator to confirm the exchange.

      # Key Exchange, Nonce, and Identification Payloads (Aggressive Mode Only)
      case diffie_hellman
      when 1
        key_length = 96
      when 2
        key_length = 128
      when 5
        key_length = 192
      when 14
        raise RuntimeError, 'TODO'
      else
        raise RuntimeError, 'Unknown Diffie Helman Value'
      end

      # Key Exchange Payload
      aggressive_payload  = ['0a'].pack('H*')                            # Next Payload (Nonce)
      aggressive_payload += ['00'].pack('H*')                            # Critical Bit
      aggressive_payload += [sprintf('%04x', key_length + 4)].pack('H*') # Payload Length (132)
      aggressive_payload += Rex::Text.rand_text_alphanumeric(key_length) # Key Exchange Data
      # Nonce Payload
      aggressive_payload += ['05'].pack('H*')                            # Next Payload (Identification)
      aggressive_payload += ['00'].pack('H*')                            # Critical Bit
      aggressive_payload += ['0018'].pack('H*')                          # Payload Length (24)
      aggressive_payload += Rex::Text.rand_text_alphanumeric(20)         # Nonce DATA
      # Identification Payload
      aggressive_payload += ['00'].pack('H*')                            # Next Payload (None)
      aggressive_payload += ['00'].pack('H*')                            # Critical Bit
      aggressive_payload += [identifier.length + 8].pack('n')            # Payload Length (id + 8)
      aggressive_payload += ['03'].pack('H*')                            # ID Type (USER_FQDN)
      aggressive_payload += ['11'].pack('H*')                            # Protocol ID (UDP)
      aggressive_payload += [datastore['CPORT']].to_i.pack('n')          # Port (e.g. 500)
      aggressive_payload += identifier if identifier                     # Identifier ID

      # Transform Payloads
      transforms_payload = [''].pack('H*')
      transforms.each_with_index do |transform, index|
        number = index + 1
        transforms_payload += generate_transform(transform[0], transform[1], transform[2], transform[3],
                                                 transform[4], transform[5], number, (number == transforms.size))
      end

      # Proposal Payload
      proposal_payload  = ['00'].pack('H*')                               # Proposal
      proposal_payload += ['00'].pack('H*')                               # Critical Bit
      proposal_payload += [sprintf('%04x', 8 + transforms_payload.size)].pack('H*') # Payload Length (152)
      proposal_payload += ['01'].pack('H*')                               # Proposal number
      proposal_payload += ['01'].pack('H*')                               # Protocol ID: ISAKMP (1)
      proposal_payload += ['00'].pack('H*')                               # SPI size: 0
      proposal_payload += [sprintf('%02x', transforms.count)].pack('H*')  # Number of Proposal Transforms

      # Security Association (SA) Payload
      sa_payload = ['04'].pack('H*')                                      # Next Payload (Key Exchange)
      sa_payload += ['00'].pack('H*')                                     # Critical Bit: Not Critical
      sa_payload += [sprintf('%04x', 12 + proposal_payload.size + transforms_payload.size)].pack('H*') # Payload Length (164)
      sa_payload += ['00000001'].pack('H*')                               # Domain of Interpretation (DOI): IPSEC (1)
      sa_payload += ['00000001'].pack('H*')                               # Situation: Identity Only (1)

      # Header Payload
      header_payload  = ['0102030405060708'].pack('H*')                   # Initiator SPI
      header_payload += ['0000000000000000'].pack('H*')                   # Responder SPI
      header_payload += ['01'].pack('H*')                                 # Next Payload (Security Association)
      header_payload += ['10'].pack('H*')                                 # Version: 1.0
      header_payload += ['04'].pack('H*')                                 # Exchange type: AGGRESSIVE (04)
      header_payload += ['00'].pack('H*')                                 # Flags:
      header_payload += ['00000000'].pack('H*')                           # Message ID
      header_payload += [sprintf('%08x', 28 + proposal_payload.size + transforms_payload.size + aggressive_payload.size)].pack('H*') # Payload Length (360)

      # Assemble packet components in correct order and return
      header_payload + sa_payload + proposal_payload + transforms_payload + aggressive_payload
    end

    def send_isakmp_phase1_main_mode_one_init(transforms)
      # The algorithms and hashes used to secure the IKE communications are agreed upon in matching IKE SAs in each peer.

      # Transform Payloads
      transforms_payload = [''].pack('H*')
      transforms.each_with_index do |transform, index|
        number = index + 1
        transforms_payload += generate_transform(transform[0], transform[1], transform[2], transform[3],
                                                 transform[4], transform[5], number, (number == transforms.size))
      end

      # Proposal Payload
      proposal_payload  = ['00'].pack('H*')                               # Proposal
      proposal_payload += ['00'].pack('H*')                               # Critical Bit
      proposal_payload += [sprintf('%04x', 8 + transforms_payload.size)].pack('H*') # Payload Length (152)
      proposal_payload += ['01'].pack('H*')                               # Proposal number
      proposal_payload += ['01'].pack('H*')                               # Protocol ID: ISAKMP (1)
      proposal_payload += ['00'].pack('H*')                               # SPI size: 0
      proposal_payload += [sprintf('%02x', transforms.count)].pack('H*')  # Number of Proposal Transforms

      # Security Association (SA) Payload
      sa_payload  = ['00'].pack('H*')                                     # Next Payload (None)
      sa_payload += ['00'].pack('H*')                                     # Critical Bit: Not Critical
      sa_payload += [sprintf('%04x', 12 + proposal_payload.size + transforms_payload.size)].pack('H*') # Payload Length (164)
      sa_payload += ['00000001'].pack('H*')                               # Domain of Interpretation (DOI): IPSEC (1)
      sa_payload += ['00000001'].pack('H*')                               # Situation: Identity Only (1)

      # Header Payload
      header_payload  = ['0102030405060708'].pack('H*')                   # Initiator SPI
      header_payload += ['0000000000000000'].pack('H*')                   # Responder SPI
      header_payload += ['01'].pack('H*')                                 # Next Payload (Security Association)
      header_payload += ['10'].pack('H*')                                 # Version: 1.0
      header_payload += ['02'].pack('H*')                                 # Exchange type: MAIN (02)
      header_payload += ['00'].pack('H*')                                 # Flags:
      header_payload += ['00000000'].pack('H*')                           # Message ID
      header_payload += [sprintf('%08x', 28 + proposal_payload.size + transforms_payload.size)].pack('H*') # Payload Length (360)

      # Assemble packet components in correct order and return
      header_payload + sa_payload + proposal_payload + transforms_payload
    end

    def send_isakmp_phase1_main_mode_two_init(diffie_hellman)
      # TODO:
      # Uses a Diffie-Hellman exchange to generate shared secret keying material used to generate shared secret keys
      # and to pass noncesâ€”random numbers sent to the other party and then signed and returned to prove their identity.
    end

    def send_isakmp_phase1_main_mode_three_init
      # TODO:
      # Verifies the other side's identity. The identity value is the IPSec peer's IP address in encrypted form. The
      # main outcome of main mode is matching IKE SAs between peers to provide a protected pipe for subsequent
      # protected ISAKMP exchanges between the IKE peers. The IKE SA specifies values for the IKE exchange: the
      # authentication method used, the encryption and hash algorithms, the Diffie-Hellman group used, the lifetime of
      # the IKE SA in seconds or kilobytes, and the shared secret key values for the encryption algorithms. The IKE SA
      # in each peer is bi-directional.
    end

    private

    def generate_transform(encryption, hash, authentication, group, life_type, life_duration, number, last)
      if encryption.is_a? Array
        # Handle special case for AES
        enc = encryption[0]
        trans_length = '0028'
        key_length = encryption[1]
      else
        enc = encryption
        trans_length = '0024'
        key_length = nil
      end

      if last
        payload  = ['00'].pack('H*')                  # Next Payload (None)
      else
        payload += ['03'].pack('H*')                  # Next Payload (Transform)
      end
      payload += ['00'].pack('H*')                    # Critical Bit
      payload += [trans_length].pack('H*')            # Payload Length
      payload += [sprintf('%02x', number)].pack('H*') # Transform number
      payload += ['01'].pack('H*')                    # Transform ID: KEY_IKE (1)
      payload += ['0000'].pack('H*')                  #
      payload += [enc].pack('H*')                     # Encryption-Algorithm
      payload += [hash].pack('H*')                    # Hash-Algorithm
      payload += [authentication].pack('H*')          # Authentication-Method
      payload += [group].pack('H*')                   # Group-Description
      if key_length
        payload += [key_length].pack('H*')            # AES Key Length
      end
      payload += [life_type].pack('H*')               # Life-Type
      payload += [life_duration].pack('H*')           # Life-Duration

      return payload
    end
  end
end
